# Плагинная архитектура подключения прикладных модулей в приложения

## Какие проблемы решает?
_**Неудобства системы добавления прикладных модулей в приложения, построенной на holder-ах:**_
- Приходится вешать спец.интерфейсы (holder) на класс *Application* для каждого прикладного модуля, которому требуется обеспечить единственный экземпляр своего компонета;
- В каждом приложении для каждого прикладного модуля приходится вызывать явно инициализацию *dagger* графа (следствие из предыдущего пункта);
- Конфигурации прикладного модуля (подписка на пуши, deeplink и прочее) разбросана по разным местам на уровне приложения;
- В каждом приложении нужно реализовывать интерфейс зависимостей прикладного модуля *Dependency*, а это довольно много кода и в ряде случаев не все тривиально;

В итоге получается много однотипного кода на уровне приложения для встраивания прикладного модуля.

Предлагается всю логику по выполнению инициализации, настройки (подписке на события авторизации, пуши и прочее) унести в прикладной модуль. Тем самым мы обеспечим возможность с минимумом усилий встраивать прикладной модуль в любое приложение.

_**Преимущества организации структуры приложения на основе плагинного подхода:**_
- На уровне приложения не требуется "вешать" холдеры на *Application*;
- Все DI-компоненты могут быть легко скрыты внутри прикладных модулей, соответственно и их инициализация тоже;
- Не требуется в каждом приложении явно имплементировать *Dependency* для каждого модуля;
- Получаем четкий контракт модуля (в виде описания плагина), в котором видно: что он предоставляет наружу, от чего зависит (жестко или нет), какая возможность подстройки присутствует;
- Подход навязывает "ленивость" инициализации, а также на уровне описания пропагандирует опциональность зависимостей.

## Терминология

Раньше **фичей** мы называли публичный интерфейс модуля, но с точки зрения семантики это не совсем удобно. **Фича** - это скорее **минимально обособленный** функционал, то есть фактически любой прикладной модуль поставляет наружу больше одной фичи.
Например, NotificationActivityIntentProvider - это фича, предоставляющая интент для открытия экрана (Activity) уведомления. Или ProfileProvider - фича, помогающая получить объект профиля по UUID.

Сам же прикладной модуль будем воспринимать как **плагин**, который может поставлять любое количество обособленных **фич**. Для описания функционала прикладного модуля создаем класс с одноименным названием (например, ProfilePlugin), в рамках которого описываем:
- какие **фичи** поставляются наружу;
- что требуется извне (обязательные и опциональные зависимости);
- какие настройки можно задать у прикладного модуля для подстройки поведения под определенные нужды: как правило посредством выставления флагов, enum'ов и прочего (например, отключение обработки пуш-уведомлений);
- что происходит при инициализации;
- что происходит при конфигурировании.

Для удобства (а также из-за особенностей работы прикладных модулей) **Плагин** прикладного модуля существует в единственном экземпляре на приложение (то есть реализуется через **object** на котлине), что позволяет унести холдеры компонентов с уровня приложения в соответствующие плагины.

Особенностью подхода является предоставление наружу и получение из вне не объектов **Feature**, а провайдеров этих фич. Это позволит на уровне таких провайдеров спрятать проверку прав, а также сделать инициализацию фич максимально "ленивой".

## Плагины
Подробное описание того, что такое плагины и как их реализовать с примерами, можно посмотреть в [документации](plugin_struct/README.md)

## Применение
Данный модуль предназначен для использования **только** на уровне приложения. 
В качестве исключения, иногда применяется в тестах.

Организация кода с использованием плагинной структуры на уровне приложения выглядит следующим образом:

```kotlin
class App : Application() {

    override fun onCreate() {
        super.onCreate()

        val pluginManager = PluginManager()

        pluginManager.registerPlugins(
            CommonUtilsPlugin,
            PermissionPlugin,
            AuthPlugin.apply {
                customizationOptions.googleAuthEnable = false
            },
            ProfilePlugin
        )

        pluginManager.configure(this)
    }
}
```

1. Все необходимые плагины настраиваются нужным образом и добавляются в **PluginManager**.
```kotlin
val pluginManager = PluginManager()

pluginManager.registerPlugins(
            CommonUtilsPlugin,
            PermissionPlugin,
            AuthPlugin.apply {
                customizationOptions.googleAuthEnable = false
            },
            ProfilePlugin
        )
```
2. Запускается этап конфигурирования
```kotlin
pluginManager.configure(application)
```
, во время которого:
1) собирауются все фичи модулей по плагинам;
2) каждому плагину встраиваются необходимые зависимости (если отсутствуют обязательные, то кидается исключение);
3) выполняется последовательная инициализация плагинов;
4) выполняется настройка плагинов.

#### Тонкая подстройка фич на уровне приложения
Существует возможность на уровне приложения подменить/скрыть какую-либо фичу для конкретного плагина или набора плагинов (иногда такое может потребоваться). Для этого создан **FeatureResolver**:
```kotlin
interface FeatureResolver {
    fun <F: Feature> resolveSingle(featureType: Class<out Feature>, caller: Plugin<*>, records: Set<PluginManager.Record<out F>>): FeatureProvider<F>?
    fun <F: Feature> resolveMulti(featureType: Class<out Feature>, caller: Plugin<*>, records: Set<PluginManager.Record<out F>>): Set<FeatureProvider<F>>?
}
```
, который можно передать в конструктор **PluginManager**. Например, так можно скрыть фичу от конкретного плагина:
```kotlin
val resolver = object : FeatureResolver {
    override fun <F : Feature> resolveSingle(
        featureType: Class<out Feature>,
        caller: Plugin<*>,
        records: Set<PluginManager.Record<out F>>
    ): FeatureProvider<F>? {
        return if(caller == IamherePlugin && featureType == PushCenter::class.java) {
            null
        } else if(records.size == 1) {
            records.first().feature as FeatureProvider<F>
        } else null
    }
    ...
}
```
В данном случае делаем *PushCenter* невидимым для плагина *IamherePlugin*.

#### Проверка плагинов и их зависимостей на уровне приложения
Поскольку в текущем варианте плагинная система построена по принципу сервис локатора, проверку работоспособности плагинов в приложении НЕ удастся проверять на этапе компиляции. (кодогенерация на данном этапе отсутствует, ждем релиза kotlin 1.5 и [KSP](https://github.com/google/ksp)). В связи с этим предлагается проверку проводить с помощью запуска одного unit-теста. 
Для этого создается тестовое приложение:
```kotlin
class TestApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        RxJavaPlugins.setErrorHandler {  }
        AppConfig.init(this)
        FirebaseApp.initializeApp(this)

        val pluginManager = AppPluginInitializer.buildPluginManager(this)
        pluginManager.configure(this)
    }
}
```
И сам unit-тест с ипользованием Robolectic:
```kotlin
@Config(
    sdk = [ Build.VERSION_CODES.P ],
    application = TestApplication::class
)
@RunWith(RobolectricTestRunner::class)
class AppPluginInitializerTest {

    @Test
    fun testPlugins() {
        val app: Application = ApplicationProvider.getApplicationContext()
    }

}
```
Этого достаточно, чтобы провалидировать, что у всех плагинов есть обязательные зависимости, каждый плагин успешно инициализируется и конфигурируется.
Поскольку в нашей системе unit-тесты запускаются при добросках, сломать зависимости будет крайне сложно.
