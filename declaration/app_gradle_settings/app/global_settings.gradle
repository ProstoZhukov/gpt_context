import javax.annotation.Nullable
import javax.annotation.Nonnull
import java.util.concurrent.Callable
import java.util.regex.Pattern

/**
 * Выполнить базовую настройку сборочного скрипта проекта (classpath, plugins, cache, etc.).
 *
 * @param settings
 * @param gradleConfigsDirPath путь до android-configs/gradle_configs.
 * @param appTypeDefault
 */
void setupGlobalSettings(Settings settings,
                         String gradleConfigsDirPath = "$androidConfigs/gradle_configs".toString(),
                         @Nullable String appTypeDefault = null) {
    configureBuildScript(settings, gradleConfigsDirPath)

    settings.includeBuild("$gradleConfigsDirPath/gradle_settings")

    settings.apply from: "$gradleConfigsDirPath/local_properties_reader.gradle"

    settings.readLocalProperties(settings, appTypeDefault ?: "")

    settings.gradle.rootProject {
        it.apply from: "$gradleConfigsDirPath/local_properties_reader.gradle"
        readLocalProperties(it, appTypeDefault ?: "")
    }

    def environment = System.getenv()
    def isCiRun = environment.containsKey("CI_BUILD") || environment.containsKey("CI_BUILD_TEST")
    settings.ext.isCiBuild = isCiRun

    configureBuildCache(settings, isCiRun)
}

ext.setupGlobalSettings = this::setupGlobalSettings

/**
 * Подключить прикладные подмодули к проекту.
 *
 * @param settings
 * @param app название приложения
 * @param submodules
 */
void includeSubmodules(Settings settings, String app, String...submodules) {
    def scriptDir = getScriptDir()
    for (String submodule : submodules) {
        settings.apply from: "${scriptDir.path}/../submodule/$submodule/${submodule}_${app}_settings.gradle"
    }
}

ext.includeSubmodules = this::includeSubmodules

/**
 * Подключить модуль контроллера к проекту.
 *
 * @param settings
 * @param app название приложения
 */
void includeControllerSources(Settings settings, String app) {
    def controller_root = "${settings.settingsDir}/../controller/$app"
    if (file(controller_root).exists()) {
        def moduleName = "controller-$app"
        include ":$moduleName"
        project(":$moduleName").projectDir = new File(controller_root)
    }
}

ext.includeControllerSources = this::includeControllerSources

/**
 * Настроить модуль контроллера к проекту. При это звать includeControllerSources отдельно не требуется.
 *
 * @param settings
 * @param app название приложения
 * @param controllerArtifactName название артефакта контроллера
 */
void setupControllerModule(Settings settings,
                           String app,
                           String controllerArtifactName = "android-$app-controller") {
    includeControllerSources(settings, app)
    settings.gradle.rootProject {
        allprojects {
            ext.androidController = controllerArtifactName
            ext.androidControllerLite = "${controllerArtifactName}-lite"
        }
    }
}

ext.setupControllerModule = this::setupControllerModule

/**
 * Определить переменные с названиями прикладных git-submodule на уровне настроек,
 * для последуюещего доступа к ним в 'submodule/название_модуля/settings.gradle'.
 *
 * @param settings
 * @param gitDir директория с файлом .gitmodules
 */
void parseGitSubmodules(Settings settings, File gitDir = settings.settingsDir) {
    measureMillis("parseGitModules") {
        def gitModules = findGitSubmodules(gitDir)
        def declaredModules = findDeclaredModules()

        declaredModules.forEach { url, dirName ->
            def path = gitModules.get(url)
            if (path != null) {
                settings.extensions.extraProperties.set(dirName, "$gitDir/$path")
            }
        }
    }
}

ext.parseGitSubmodules = this::parseGitSubmodules

/**
 * Настроить дополнительные classpath'ы в блоке buildscript у build.gradle.
 *
 * @param settings
 * @param block блок настройки ScriptHandler.
 */
static void customizeBuildScript(Settings settings, Closure block) {
    settings.gradle.rootProject { project ->
        project.buildscript { scriptHandler ->
            block(scriptHandler, project)
        }
    }
}

ext.customizeBuildScript = this::customizeBuildScript

/**
 * Выполнить проверку Gradle и gradle-options.
 *
 * @param settings
 * @param gradleVersion требуемая версия Gradle (не путать с AGP).
 * @param requiredProperties требуемые опции в 'gradle.options'.
 * @param deprecatedProperties устревшие опции в 'gradle.options', от которых требуется избавиться.
 */
static void checkGradle(Settings settings,
                        String gradleVersion,
                        Map<String, Object> requiredProperties = Collections.emptyMap(),
                        Set<String> deprecatedProperties = Collections.emptySet()) {
    measureMillis("checkGradle") {
        checkGradleVersion(settings, gradleVersion)
        checkGradleProperties(settings, requiredProperties, deprecatedProperties)
    }
}

ext.checkGradle = this::checkGradle

private File getScriptDir() {
    return file(".")
}

private def configureBuildScript(Settings settings, String gradleConfigsDirPath) {
    apply from: "$gradleConfigsDirPath/version_catalog.gradle"

    settings.gradle.rootProject {
        apply from: "$gradleConfigsDirPath/versions.gradle"
        apply from: "$gradleConfigsDirPath/project_params.gradle"

        buildscript {
            //используется в модулях зависимостях(наприм. common/application_tools/build.gradle), удалить после перехода на общие gradle скрипты
            ext.kotlinVersion = versions.kotlin

            addRepos(repositories)

            allprojects {
                addRepos(repositories)
            }

            dependencies { handler ->
                addBaseBuildScriptDependency(handler)
                classpath deps.google_services_plugin
                classpath deps.firebase_crashlytics_plugin
                classpath deps.firebase_perf_plugin
                classpath deps.detekt_gradle_plugin
            }
        }
    }
}

private static def configureBuildCache(Settings settings, Boolean isRemoteCacheEnabled) {
    settings.buildCache {
        if (!isRemoteCacheEnabled) {
            local {
                enabled = true
            }
        } else {
            remote(HttpBuildCache) {
                String artifactory_url = System.getenv("artifactory_url") as String
                String artifactory_user = System.getenv("artifactory_user") as String
                String artifactory_password = System.getenv("artifactory_password") as String
                String app_name = System.getenv("app_name") as String
                url = "${artifactory_url}/gradle_${app_name}_cache/"
                push = true
                credentials {
                    username = "${artifactory_user}"
                    password = "${artifactory_password}"
                }
            }
        }
    }
}

private static Map<String, String> findGitSubmodules(File gitDir)  {
    Map<String, String> gitModules = new HashMap<>()
    new File("$gitDir/.gitmodules").withReader { reader ->
        Pattern moduleHeaderPattern = Pattern.compile("\\[submodule .*\\]")
        String path = null
        String url = null
        String line = null
        while ((line = reader.readLine()) != null) {
            String normalizedLine = line.strip()
            if (normalizedLine.matches(moduleHeaderPattern)) {
                if (path != null && url != null) {
                    gitModules.put(url, path)
                }
                path = null
                url = null
            } else if (normalizedLine.startsWith("path")) {
                path = normalizedLine.split("=")[1].strip()
            } else if (normalizedLine.startsWith("url")) {
                url = normalizedLine.split("=")[1].strip()
            }
        }
        if (path != null && url != null) {
            gitModules.put(url, path)
        }
    }
    return gitModules
}

private Map<String, String> findDeclaredModules() {
    Map<String, String> modules = new HashMap<>()

    def files = new ArrayList<>()
    new File(getScriptDir(), "../submodule").eachFileRecurse { File file ->
        if (file.isFile() && file.name.endsWith(".properties")) {
            files.add(file)
        }
    }

    for (File file in files) {
        def props = readProperties(file)
        String dirName = props.getProperty("dirName")
        String url = props.getProperty("url")
        if (url != null && dirName != null) {
            modules.put(url, dirName)
        }
    }

    return modules
}

private static Properties readProperties(File file) {
    Properties properties = new Properties()
    if (!file.exists()) {
        throw new IllegalArgumentException("File ${file.path} doesn't exist")
    }
    properties.load(file.newDataInputStream())
    return properties
}

private static void checkGradleVersion(Settings settings, String requiredGradleVersion) {
    def currentGradleVersion = settings.gradle.gradleVersion
    if (currentGradleVersion != requiredGradleVersion) {
        File gradleWrapperPropertiesFile = new File(settings.settingsDir, "gradle/wrapper/gradle-wrapper.properties")
        if (!gradleWrapperPropertiesFile.exists()) {
            throw new IllegalStateException("Couldn't find $gradleWrapperPropertiesFile.path")
        }
        String updatedProperties = gradleWrapperPropertiesFile.text
                .replaceAll(currentGradleVersion, requiredGradleVersion)
        gradleWrapperPropertiesFile.text = updatedProperties
        def message = "Gradle: using $currentGradleVersion but $requiredGradleVersion expected. We updated local config. Try again. Don't forget to commit changes."
        throw new IllegalStateException(message)
    }
}

private static void checkGradleProperties(Settings settings,
                                          Map<String, Object> requiredProperties,
                                          Set<String> deprecatedProperties) {
    def propertyFile = new File(settings.settingsDir, "gradle.properties")
    def props = readProperties(propertyFile)

    deprecatedProperties.forEach { prop ->
        if (props.containsKey(prop)) {
            throw new IllegalStateException("${propertyFile.path} contains deprecated property $prop")
        }
    }

    requiredProperties.forEach { key, value ->
        if (props.containsKey(key) && props.getProperty(key) != value) {
            throw new IllegalStateException("${propertyFile.path} contains property $key=${props.getProperty(key)} but $key=$value required.")
        }
    }
}

private static <V> V measureMillis(String operationName, Callable<V> block) {
    long timeBeforeDiscover = System.currentTimeMillis()

    def result = block.call()

    long timeAfterDiscover = System.currentTimeMillis()
    long diff = timeAfterDiscover - timeBeforeDiscover
    println(operationName + " takes " + diff + " ms")

    return result
}

public enum AndroidAccountManager {
    SBIS_ACCOUNT("SBIS.Account"),
    SABY_ACCOUNT("SABY.Account"),
    SABY_BUNDLE_ACCOUNT("SABY.MobileAccount"),
    SETTY_BUNDLE_ACCOUNT("Setty.Account");

    public final String type

    AndroidAccountManager(@Nonnull String type) {
        this.type = type
    }
}

ext.AndroidAccountManager = AndroidAccountManager
settings.gradle.rootProject {
    ext.AndroidAccountManager = AndroidAccountManager
}

apply from: "./region_settings.gradle"